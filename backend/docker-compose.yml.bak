# Generated by nself build - DO NOT EDIT MANUALLY
# Project: nself-tv
# Date: 2026-02-14 16:41:12
# Build Version: unknown

networks:
  nself-tv_network:
    name: nself-tv_network
    driver: bridge

volumes:
  postgres_data:
    driver: local
  nginx_cache:
    driver: local
  redis_data:
  minio_data:
  meilisearch_data:
  grafana_data:
  prometheus_data:
  loki_data:
  tempo_data:
  alertmanager_data:

services:
  # ============================================
  # Core Services
  # ============================================

  # PostgreSQL Database
  # SECURITY: Bound to localhost only - never expose database to public internet
  postgres:
    image: postgres:15
    container_name: ${PROJECT_NAME}_postgres
    restart: unless-stopped
    networks:
      - ${DOCKER_NETWORK}
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB:-${PROJECT_NAME}}
      POSTGRES_HOST_AUTH_METHOD: scram-sha-256
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./postgres/init:/docker-entrypoint-initdb.d:ro
    ports:
      # SECURITY: Bind to localhost only - prevents external access
      - "127.0.0.1:${POSTGRES_PORT:-5432}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres}"]
      interval: 10s
      timeout: 5s
      retries: 5


  # Hasura GraphQL Engine
  hasura:
    image: hasura/graphql-engine:v2.38.0
    container_name: ${PROJECT_NAME}_hasura
    restart: unless-stopped
    user: "1001:1001"
    networks:
      - ${DOCKER_NETWORK}
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      HASURA_GRAPHQL_DATABASE_URL: ${DATABASE_URL}
      HASURA_GRAPHQL_ADMIN_SECRET: ${HASURA_GRAPHQL_ADMIN_SECRET}
      HASURA_GRAPHQL_ENABLE_CONSOLE: "true"
      HASURA_GRAPHQL_DEV_MODE: ${HASURA_DEV_MODE:-false}
      HASURA_GRAPHQL_ENABLE_TELEMETRY: "false"
      HASURA_GRAPHQL_CORS_DOMAIN: "${HASURA_GRAPHQL_CORS_DOMAIN}"
      HASURA_GRAPHQL_LOG_LEVEL: ${HASURA_LOG_LEVEL:-info}
      HASURA_GRAPHQL_JWT_SECRET: ${HASURA_GRAPHQL_JWT_SECRET}
      HASURA_GRAPHQL_UNAUTHORIZED_ROLE: public
    ports:
      # SECURITY: Bind to localhost only - access via nginx reverse proxy
      - "127.0.0.1:${HASURA_PORT:-8080}:8080"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/healthz"]
      interval: 30s
      timeout: 10s
      retries: 5

  # Hasura Auth Service
  auth:
    image: nhost/hasura-auth:latest
    container_name: ${PROJECT_NAME}_auth
    restart: unless-stopped
    networks:
      - ${DOCKER_NETWORK}
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      AUTH_HOST: "0.0.0.0"
      AUTH_PORT: "4000"
      AUTH_LOG_LEVEL: ${AUTH_LOG_LEVEL:-info}
      DATABASE_URL: postgresql://${POSTGRES_USER:-postgres}:${POSTGRES_PASSWORD:-postgres}@postgres:5432/${POSTGRES_DB:-${PROJECT_NAME}}
      AUTH_DATABASE_URL: postgresql://${POSTGRES_USER:-postgres}:${POSTGRES_PASSWORD:-postgres}@postgres:5432/${POSTGRES_DB:-${PROJECT_NAME}}
      HASURA_GRAPHQL_DATABASE_URL: postgresql://${POSTGRES_USER:-postgres}:${POSTGRES_PASSWORD:-postgres}@postgres:5432/${POSTGRES_DB:-${PROJECT_NAME}}
      POSTGRES_HOST: postgres
      POSTGRES_PORT: 5432
      PGHOST: postgres
      PGPORT: 5432
      PGUSER: ${POSTGRES_USER:-postgres}
      PGPASSWORD: ${POSTGRES_PASSWORD:-postgres}
      PGDATABASE: ${POSTGRES_DB:-${PROJECT_NAME}}
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
      POSTGRES_DATABASE: ${POSTGRES_DB:-${PROJECT_NAME}}
      AUTH_SERVER_URL: ${AUTH_SERVER_URL:-http://localhost:4000}
      AUTH_CLIENT_URL: ${AUTH_CLIENT_URL:-http://localhost:3000}
      AUTH_JWT_SECRET: ${AUTH_JWT_SECRET}
      AUTH_JWT_TYPE: ${AUTH_JWT_TYPE:-HS256}
      AUTH_JWT_KEY: ${AUTH_JWT_KEY:-${AUTH_JWT_SECRET}}
      HASURA_GRAPHQL_JWT_SECRET: ${HASURA_GRAPHQL_JWT_SECRET}
      HASURA_GRAPHQL_GRAPHQL_URL: ${HASURA_GRAPHQL_GRAPHQL_URL:-http://hasura:8080/v1/graphql}
      HASURA_GRAPHQL_ADMIN_SECRET: ${HASURA_GRAPHQL_ADMIN_SECRET}
      AUTH_ACCESS_TOKEN_EXPIRES_IN: ${AUTH_ACCESS_TOKEN_EXPIRES_IN:-900}
      AUTH_REFRESH_TOKEN_EXPIRES_IN: ${AUTH_REFRESH_TOKEN_EXPIRES_IN:-2592000}
      AUTH_SMTP_HOST: ${AUTH_SMTP_HOST:-mailpit}
      AUTH_SMTP_PORT: ${AUTH_SMTP_PORT:-1025}
      AUTH_SMTP_USER: ${AUTH_SMTP_USER}
      AUTH_SMTP_PASS: ${AUTH_SMTP_PASS}
      AUTH_SMTP_SECURE: ${AUTH_SMTP_SECURE:-false}
      AUTH_SMTP_SENDER: ${AUTH_SMTP_SENDER:-noreply@${BASE_DOMAIN:-localhost}}
      AUTH_EMAIL_SIGNIN_EMAIL_VERIFIED_REQUIRED: ${AUTH_EMAIL_SIGNIN_EMAIL_VERIFIED_REQUIRED:-false}
    ports:
      # SECURITY: Bind to localhost only - access via nginx reverse proxy
      - "127.0.0.1:${AUTH_PORT:-4000}:4000"
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:4000/healthz"]
      interval: 30s
      timeout: 10s
      retries: 5
  nginx:
    image: nginx:alpine
    container_name: ${PROJECT_NAME:-myproject}_nginx
    restart: unless-stopped
    ports:
      - "${NGINX_PORT:-80}:80"
      - "${NGINX_SSL_PORT:-443}:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/conf.d:/etc/nginx/conf.d:ro
      - ./nginx/sites:/etc/nginx/sites:ro
      - ./nginx/includes:/etc/nginx/includes:ro
      - ./ssl/certificates:/etc/nginx/ssl:ro
      - nginx_cache:/var/cache/nginx
    environment:
      - BASE_DOMAIN=${BASE_DOMAIN:-localhost}
      - PROJECT_NAME=${PROJECT_NAME:-myproject}
      - ENV=${ENV:-dev}
    networks:
      - ${PROJECT_NAME:-myproject}_network
    depends_on:
      - hasura
      - auth
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 -O /dev/null http://127.0.0.1/ || exit 1"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

  # ============================================
  # Optional Services
  # ============================================

  # MinIO Volume Permission Fix - Init Container
  # Fixes permissions on MinIO data volume for non-root user (1000:1000)
  # This runs once before MinIO starts to ensure the container can write to the volume
  minio-init:
    image: busybox:latest
    container_name: ${PROJECT_NAME}_minio_init
    user: root
    networks:
      - ${DOCKER_NETWORK}
    volumes:
      - minio_data:/data
    command: >
      sh -c "
        echo '→ Fixing MinIO volume permissions...';
        chown -R 1000:1000 /data;
        chmod -R 755 /data;
        echo '✓ MinIO volume permissions fixed';
      "
    labels:
      - "nself.type=init-container"
      - "nself.service=minio"

  # MinIO Object Storage
  # SECURITY: Bound to localhost only - access via nginx reverse proxy
  minio:
    image: minio/minio:latest
    container_name: ${PROJECT_NAME}_minio
    restart: unless-stopped
    user: "1000:1000"
    networks:
      - ${DOCKER_NETWORK}
    depends_on:
      minio-init:
        condition: service_completed_successfully
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
      MINIO_DEFAULT_BUCKETS: ${MINIO_DEFAULT_BUCKETS:-uploads}
      MINIO_REGION: ${MINIO_REGION:-us-east-1}
    command: server /data --console-address ":9001"
    volumes:
      - minio_data:/data
    ports:
      # SECURITY: Bind to localhost only - prevents external access
      - "127.0.0.1:${MINIO_PORT:-9000}:9000"
      - "127.0.0.1:${MINIO_CONSOLE_PORT:-9001}:9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3

  # MinIO Client - One-time bucket initialization (run with --profile init-containers)
  minio-client:
    image: minio/mc:latest
    container_name: ${PROJECT_NAME}_minio_client
    restart: "no"
    profiles:
      - init-containers
    networks:
      - ${DOCKER_NETWORK}
    depends_on:
      minio:
        condition: service_healthy
    labels:
      - "nself.type=init-container"
      - "nself.auto-remove=true"
    entrypoint: >
      /bin/sh -c "
      set -e;
      echo '→ Initializing MinIO buckets...';
      /usr/bin/mc config host add myminio http://minio:9000 ${MINIO_ROOT_USER} ${MINIO_ROOT_PASSWORD};
      for bucket in $(echo ${MINIO_DEFAULT_BUCKETS:-uploads} | tr ',' ' '); do
        /usr/bin/mc mb -p myminio/$$bucket 2>/dev/null || echo \"  Bucket $$bucket exists\";
        /usr/bin/mc anonymous set download myminio/$$bucket 2>/dev/null || true;
      done;
      echo '✓ MinIO initialization complete';
      "

  # Redis Cache
  # SECURITY: Bound to 127.0.0.1 only - never expose Redis to public internet
  # Password authentication enabled when REDIS_PASSWORD is set
  redis:
    image: redis:7
    container_name: ${PROJECT_NAME}_redis
    restart: unless-stopped
    user: "999:999"
    networks:
      - ${DOCKER_NETWORK}
    command: redis-server --appendonly yes --protected-mode no
    volumes:
      - redis_data:/data
    ports:
      # SECURITY: Bind to localhost only - prevents external access
      - "127.0.0.1:${REDIS_PORT:-6379}:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Mailpit - Email Testing Tool
  mailpit:
    image: axllent/mailpit:latest
    container_name: ${PROJECT_NAME}_mailpit
    restart: unless-stopped
    user: "1000:1000"
    networks:
      - ${DOCKER_NETWORK}
    environment:
      MP_UI_BIND_ADDR: 0.0.0.0:8025
      MP_SMTP_BIND_ADDR: 0.0.0.0:1025
      MP_SMTP_AUTH_ACCEPT_ANY: 1
      MP_SMTP_AUTH_ALLOW_INSECURE: 1
      MP_MAX_MESSAGES: ${MAILPIT_MAX_MESSAGES:-500}
    ports:
      # SECURITY: Bind to localhost only - access via nginx reverse proxy
      - "127.0.0.1:${MAILPIT_SMTP_PORT:-1025}:1025"
      - "127.0.0.1:${MAILPIT_UI_PORT:-8025}:8025"
    healthcheck:
      test: ["CMD", "nc", "-z", "localhost", "8025"]
      interval: 30s
      timeout: 10s
      retries: 5

  # MeiliSearch Volume Permission Fix - Init Container
  # Fixes permissions on MeiliSearch data volume for non-root user (1000:1000)
  # This runs once before MeiliSearch starts to ensure the container can write to the volume
  meilisearch-init:
    image: busybox:latest
    container_name: ${PROJECT_NAME}_meilisearch_init
    user: root
    networks:
      - ${DOCKER_NETWORK}
    volumes:
      - meilisearch_data:/meili_data
    command: >
      sh -c "
        echo '→ Fixing MeiliSearch volume permissions...';
        chown -R 1000:1000 /meili_data;
        chmod -R 755 /meili_data;
        echo '✓ MeiliSearch volume permissions fixed';
      "
    labels:
      - "nself.type=init-container"
      - "nself.service=meilisearch"

  # MeiliSearch - Lightning Fast Search
  # SECURITY: Bound to localhost only - access via nginx reverse proxy
  meilisearch:
    image: getmeili/meilisearch:${MEILISEARCH_VERSION:-v1.5}
    container_name: ${PROJECT_NAME}_meilisearch
    restart: unless-stopped
    user: "1000:1000"
    networks:
      - ${DOCKER_NETWORK}
    depends_on:
      meilisearch-init:
        condition: service_completed_successfully
    environment:
      MEILI_MASTER_KEY: ${SEARCH_API_KEY:-${MEILISEARCH_MASTER_KEY}}
      MEILI_ENV: ${MEILI_ENV:-development}
      MEILI_HTTP_ADDR: 0.0.0.0:7700
      MEILI_NO_ANALYTICS: true
    volumes:
      - meilisearch_data:/meili_data
    ports:
      # SECURITY: Bind to localhost only - prevents external access
      - "127.0.0.1:${SEARCH_PORT:-${MEILISEARCH_PORT:-7700}}:7700"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:7700/health"]
      interval: 30s
      timeout: 10s
      retries: 5

  # ============================================
  # Monitoring Services
  # ============================================

  # Prometheus - Metrics Collection
  # SECURITY: Bound to localhost only - access via nginx reverse proxy
  prometheus:
    image: prom/prometheus:latest
    container_name: ${PROJECT_NAME}_prometheus
    restart: unless-stopped
    user: "65534:65534"
    networks:
      - ${DOCKER_NETWORK}
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/usr/share/prometheus/console_libraries'
      - '--web.console.templates=/usr/share/prometheus/consoles'
      - '--web.enable-lifecycle'
    volumes:
      - prometheus_data:/prometheus
      - ./monitoring/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
    ports:
      # SECURITY: Bind to localhost only - prevents external access
      - "127.0.0.1:${PROMETHEUS_PORT:-9090}:9090"
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:9090/-/healthy"]
      interval: 30s
      timeout: 10s
      retries: 5

  # Grafana - Monitoring Dashboard
  # SECURITY: Bound to localhost only - access via nginx reverse proxy
  grafana:
    image: grafana/grafana:latest
    container_name: ${PROJECT_NAME}_grafana
    restart: unless-stopped
    user: "472:472"
    networks:
      - ${DOCKER_NETWORK}
    environment:
      GF_SECURITY_ADMIN_USER: ${GRAFANA_ADMIN_USER}
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_ADMIN_PASSWORD}
      GF_INSTALL_PLUGINS: ${GRAFANA_PLUGINS:-}
      GF_SERVER_ROOT_URL: ${GRAFANA_ROOT_URL:-http://localhost:3000}
      GF_ANALYTICS_REPORTING_ENABLED: "false"
      GF_ANALYTICS_CHECK_FOR_UPDATES: "false"
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/dashboards:/etc/grafana/provisioning/dashboards:ro
      - ./monitoring/grafana/datasources:/etc/grafana/provisioning/datasources:ro
    ports:
      # SECURITY: Bind to localhost only - prevents external access
      - "127.0.0.1:${GRAFANA_PORT:-3000}:3000"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 5

  # Loki - Log Aggregation
  # SECURITY: Bound to localhost only - access via nginx reverse proxy
  loki:
    image: grafana/loki:2.9.0
    container_name: ${PROJECT_NAME}_loki
    restart: unless-stopped
    user: "10001:10001"
    networks:
      - ${DOCKER_NETWORK}
    command: -config.file=/etc/loki/local-config.yaml
    volumes:
      - loki_data:/loki
      - ./monitoring/loki/local-config.yaml:/etc/loki/local-config.yaml:ro
    ports:
      # SECURITY: Bind to localhost only - prevents external access
      - "127.0.0.1:${LOKI_PORT:-3100}:3100"
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:3100/ready"]
      interval: 30s
      timeout: 10s
      retries: 5

  # Promtail - Log Collector for Loki
  promtail:
    image: grafana/promtail:2.9.0
    container_name: ${PROJECT_NAME}_promtail
    restart: unless-stopped
    networks:
      - ${DOCKER_NETWORK}
    depends_on:
      - loki
    command: -config.file=/etc/promtail/config.yml
    volumes:
      - /var/log:/var/log:ro
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - ./monitoring/promtail/config.yml:/etc/promtail/config.yml:ro
    healthcheck:
      test: ["CMD-SHELL", "kill -0 1"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

  # ============================================
  # Monitoring Exporters & Tracing
  # ============================================

  # Tempo - Distributed Tracing
  # SECURITY: Bound to localhost only - access via nginx reverse proxy
  tempo:
    image: grafana/tempo:latest
    container_name: ${PROJECT_NAME}_tempo
    restart: unless-stopped
    user: "10001:10001"
    command: [ "-config.file=/etc/tempo.yaml" ]
    volumes:
      - ./monitoring/tempo/tempo.yml:/etc/tempo.yaml:ro
      - tempo_data:/var/tempo
    ports:
      # SECURITY: Bind to localhost only - prevents external access
      - "127.0.0.1:${TEMPO_PORT:-3200}:3200"
      - "127.0.0.1:14268:14268"  # Jaeger ingest
    networks:
      - ${DOCKER_NETWORK}
    # Note: Tempo uses distroless image (no shell/curl/wget)
    # Health monitoring via Prometheus scraping /ready endpoint instead
    # Container recovery handled by restart: unless-stopped

  # Alertmanager - Alert Routing
  # SECURITY: Bound to localhost only - access via nginx reverse proxy
  alertmanager:
    image: prom/alertmanager:latest
    container_name: ${PROJECT_NAME}_alertmanager
    restart: unless-stopped
    user: "65534:65534"
    volumes:
      - ./monitoring/alertmanager:/etc/alertmanager:ro
      - alertmanager_data:/alertmanager
    command:
      - '--config.file=/etc/alertmanager/alertmanager.yml'
      - '--storage.path=/alertmanager'
    ports:
      # SECURITY: Bind to localhost only - prevents external access
      - "127.0.0.1:${ALERTMANAGER_PORT:-9093}:9093"
    networks:
      - ${DOCKER_NETWORK}
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:9093/-/healthy"]
      interval: 30s
      timeout: 10s
      retries: 5

  # cAdvisor - Container Metrics
  # SECURITY: Bound to localhost only - Prometheus scrapes internally
  cadvisor:
    image: gcr.io/cadvisor/cadvisor:latest
    container_name: ${PROJECT_NAME}_cadvisor
    restart: unless-stopped
    privileged: true
    volumes:
      - /var/run:/var/run:ro
      - /var/lib/docker:/var/lib/docker:ro
    ports:
      # SECURITY: Bind to localhost only - prevents external access
      - "127.0.0.1:${CADVISOR_PORT:-8082}:8080"
    networks:
      - ${DOCKER_NETWORK}
    command:
      - '--housekeeping_interval=10s'
      - '--docker_only=true'

  # Node Exporter - Host Metrics
  # SECURITY: Bound to localhost only - Prometheus scrapes internally
  node-exporter:
    image: prom/node-exporter:latest
    container_name: ${PROJECT_NAME}_node_exporter
    restart: unless-stopped
    user: "65534:65534"
    pid: host
    volumes:
      - /proc:/host/proc:ro
      - /sys:/host/sys:ro
      - /:/rootfs:ro
    command:
      - '--path.procfs=/host/proc'
      - '--path.rootfs=/rootfs'
      - '--path.sysfs=/host/sys'
      - '--collector.filesystem.mount-points-exclude=^/(sys|proc|dev|host|etc)(72539|/)'
    ports:
      # SECURITY: Bind to localhost only - prevents external access
      - "127.0.0.1:${NODE_EXPORTER_PORT:-9100}:9100"
    networks:
      - ${DOCKER_NETWORK}
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:9100/metrics"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

  # Postgres Exporter - Database Metrics
  # SECURITY: Bound to localhost only - Prometheus scrapes internally
  postgres-exporter:
    image: prometheuscommunity/postgres-exporter:latest
    container_name: ${PROJECT_NAME}_postgres_exporter
    restart: unless-stopped
    user: "65534:65534"
    environment:
      DATA_SOURCE_NAME: "postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}?sslmode=disable"
    ports:
      # SECURITY: Bind to localhost only - prevents external access
      - "127.0.0.1:${POSTGRES_EXPORTER_PORT:-9187}:9187"
    networks:
      - ${DOCKER_NETWORK}
    depends_on:
      - postgres
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:9187/metrics"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

  # Redis Exporter - Redis Metrics
  # SECURITY: Bound to localhost only - Prometheus scrapes internally
  redis-exporter:
    image: oliver006/redis_exporter:latest
    container_name: ${PROJECT_NAME}_redis_exporter
    restart: unless-stopped
    user: "59000:59000"
    environment:
      REDIS_ADDR: "redis://redis:6379"
    ports:
      # SECURITY: Bind to localhost only - prevents external access
      - "127.0.0.1:${REDIS_EXPORTER_PORT:-9121}:9121"
    networks:
      - ${DOCKER_NETWORK}
    depends_on:
      - redis
    healthcheck:
      test: ["CMD", "/redis_exporter", "--version"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

# End of generated docker-compose.yml
